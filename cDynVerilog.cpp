/******************************************************************************
 Copyright 2012 Victor Yurkovsky

    This file is part of FPGAsm

    FPGAsm is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    FPGAsm is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FPGAsm.  If not, see <http://www.gnu.org/licenses/>.
******************************************************************************/
// This file is included from cDyn.cpp.  It was separated purely for
// convenience as cDyn got too long, but it made no sense (as usual) to
// break it out into a class hierarchy (I really don't want to introduce
// templates here).

/*=====================================================================
Verilog output is a little different.  First of all, we need to infer
the BELs and the bel wiring for the primitives.
Wiring is different also - instead of trolling for primitive endpoints,
we start at the top module and trace the wiring from its input/outputs.
======================================================================*/
#include "cCfgSLICE.h"
void CLASS::verilog(){
  //called on the fake top sub...
  fprintf(fout,"/******************************************************************************\n");
  fprintf(fout," RPM %s\n Generated by fpgasm\n",hero->name);
  fprintf(fout,"******************************************************************************/\n");
  fprintf(fout,"module %s(\n",hero->name);
  // Let's output the pins
//fprintf(stderr,"HERO %d PINS %p\n",i,hero->pins);

  cCollection* pins = hero->pins;
  U32 pincnt = pins->size;
  U32 i; for(i=0;i<pincnt;i++){
    cDatum* pin = pins->data[i];
    if(pin->pinDir)
      fputs("  output ",fout);
    else
      fputs("  input ",fout);
    if(pin->pinBusWidth>1)
      fprintf(fout,"[%d:0] ",pin->pinBusWidth-1);
    fputs(pins->name[i],fout);
    if(i!=pincnt-1)
      fputs(",\n",fout);
    else
      fputs("\n",fout);
  }
  fputs(");\n",fout);
//  hero->pins->dump(stderr,"pins");
  
  verilogDefs();
}


void CLASS::verilogDefs(){
  if(hero->type->isPrimitive()){
    int icfg = pparams->find("cfg");
    if(-1==icfg){
      errorIn("verilogDefs");
      fprintf(stderr,"No cfg parameters in %s\n", hero->name);
      error(-1);
    }
    //A primitive.  Let's output it if we can.
    if(0==strncmp("SLICE",hero->type->name,5)){ //any kind of slice
      //get the cfg for this dyn
      cCfgSLICE* cfg = (cCfgSLICE*)pparams->data[icfg]->valCfgs;
      cfg->verilog(fout,this);

// fprintf(stderr,"cfg is at %p\n",cfg);
// cfg->dump(stderr);
      return;
    }
    errorIn("verilogDefs");
    fprintf(stderr,"Primitive type %s is not supported for verilog\n",
            hero->type->name);
    error(-1);
  } else {
    /*not a primitive, a regular module.  Do not output, continue
      decomposing it */
      int i;
      for(i=0;i<psubcnt;i++){
        (psubs[i])->verilogDefs();
    }
  }

  
}
